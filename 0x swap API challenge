import { config as dotenv } from "dotenv";
import {
  createWalletClient,
  http,
  getContract,
  erc20Abi,
  parseUnits,
  maxUint256,
  publicActions,
  concat,
  numberToHex,
  size,
} from "viem";
import type { Hex } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { scroll } from "viem/chains";
import { wethAbi } from "./abi/weth-abi";

/* For the 0x Challenge on Scroll, implement the following

1. Display the percentage breakdown of liquidity sources
2. Monetize your app with affiliate fees and surplus collection
3. Display buy/sell tax for tokens with tax
4. Display all sources of liquidity on Scroll

*/

const qs = require("qs");

// Load environment variables
dotenv();
const { PRIVATE_KEY, ZERO_EX_API_KEY, ALCHEMY_HTTP_TRANSPORT_URL } =
  process.env;

// Validate requirements
if (!PRIVATE_KEY) throw new Error("missing PRIVATE_KEY.");
if (!ZERO_EX_API_KEY) throw new Error("missing ZERO_EX_API_KEY.");
if (!ALCHEMY_HTTP_TRANSPORT_URL)
  throw new Error("missing ALCHEMY_HTTP_TRANSPORT_URL.");

// Fetch headers
const headers = new Headers({
  "Content-Type": "application/json",
  "0x-api-key": ZERO_EX_API_KEY,
  "0x-version": "v2",
});

// Setup wallet client
const client = createWalletClient({
  account: privateKeyToAccount(`0x${PRIVATE_KEY}` as `0x${string}`),
  chain: scroll,
  transport: http(ALCHEMY_HTTP_TRANSPORT_URL),
}).extend(publicActions); // Extend wallet client with publicActions for public client

const [address] = await client.getAddresses();

// Set up contracts
const weth = getContract({
  address: "0x5300000000000000000000000000000000000004",
  abi: wethAbi,
  client,
});
const wsteth = getContract({
  address: "0xf610A9dfB7C89644979b4A0f27063E9e7d7Cda32",
  abi: erc20Abi,
  client,
});

const main = async () => {
  // Specify sell amount
  const decimals = (await weth.read.decimals()) as number;
  const sellAmount = parseUnits("0.1", decimals);

  // 1. Fetch price
  const priceParams = new URLSearchParams({
    chainId: client.chain.id.toString(),
    sellToken: weth.address,
    buyToken: wsteth.address,
    sellAmount: sellAmount.toString(),
    taker: client.account.address,

    // Task 2: Monetize your app with affiliate fees and surplus collection
    affiliateAddress: client.account.address, // Replace with your affiliate address if different
    feeRecipient: client.account.address,     // Replace with your fee recipient address if different
    buyTokenPercentageFee: "0.5",             // 0.5% affiliate fee
    intentOnFilling: "true",                  // Enable surplus collection
  });

  const priceResponse = await fetch(
    "https://api.0x.org/swap/permit2/price?" + priceParams.toString(),
    {
      headers,
    }
  );

  const price = await priceResponse.json();
  console.log("Fetching price to swap 0.1 WETH for wstETH");
  console.log(
    `https://api.0x.org/swap/permit2/price?${priceParams.toString()}`
  );
  console.log("priceResponse: ", price);

  // 2. Check if taker needs to set an allowance for Permit2
  if (price.issues && price.issues.allowance !== null) {
    try {
      const { request } = await weth.simulate.approve([
        price.issues.allowance.spender,
        maxUint256,
      ]);
      console.log("Approving Permit2 to spend WETH...", request);
      // Set approval
      const hash = await weth.write.approve(request.args);
      console.log(
        "Approved Permit2 to spend WETH.",
        await client.waitForTransactionReceipt({ hash })
      );
    } catch (error) {
      console.log("Error approving Permit2:", error);
    }
  } else {
    console.log("WETH already approved for Permit2");
  }

  // 3. Fetch quote
  const quoteParams = new URLSearchParams();
  for (const [key, value] of priceParams.entries()) {
    quoteParams.append(key, value);
  }

  const quoteResponse = await fetch(
    "https://api.0x.org/swap/permit2/quote?" + quoteParams.toString(),
    {
      headers,
    }
  );

  const quote = await quoteResponse.json();
  console.log("Fetching quote to swap 0.1 WETH for wstETH");
  console.log("quoteResponse: ", quote);

  // Task 1: Display the percentage breakdown of liquidity sources
  if (quote.route && quote.route.fills && quote.route.fills.length > 0) {
    const fills = quote.route.fills;
    const sources = {};

    fills.forEach((fill) => {
      const sourceName = fill.source || "Unknown";
      const proportionBps = parseInt(fill.proportionBps, 10) || 0;
      const percentage = proportionBps / 100; // Convert bps to percentage

      if (sources[sourceName]) {
        sources[sourceName] += percentage;
      } else {
        sources[sourceName] = percentage;
      }
    });

    const sourceNames = Object.keys(sources);
    console.log(`${sourceNames.length} Sources`);
    sourceNames.forEach((source) => {
      const percentage = sources[source].toFixed(2);
      console.log(`${source}: ${percentage}%`);
    });
  } else {
    console.log("No route information available.");
  }

  // Task 3: Display buy/sell tax information
  if (quote.tokenMetadata) {
    const { buyToken, sellToken } = quote.tokenMetadata;

    const taxes = [];

    if (buyToken) {
      const buyTaxBps = parseInt(buyToken.buyTaxBps, 10) || 0;
      if (buyTaxBps > 0) {
        taxes.push(`Buy Token Buy Tax: ${(buyTaxBps / 100).toFixed(2)}%`);
      }
      const sellTaxBps = parseInt(buyToken.sellTaxBps, 10) || 0;
      if (sellTaxBps > 0) {
        taxes.push(`Buy Token Sell Tax: ${(sellTaxBps / 100).toFixed(2)}%`);
      }
    }

    if (sellToken) {
      const buyTaxBps = parseInt(sellToken.buyTaxBps, 10) || 0;
      if (buyTaxBps > 0) {
        taxes.push(`Sell Token Buy Tax: ${(buyTaxBps / 100).toFixed(2)}%`);
      }
      const sellTaxBps = parseInt(sellToken.sellTaxBps, 10) || 0;
      if (sellTaxBps > 0) {
        taxes.push(`Sell Token Sell Tax: ${(sellTaxBps / 100).toFixed(2)}%`);
      }
    }

    if (taxes.length > 0) {
      console.log("Token Taxes:");
      taxes.forEach((taxInfo) => {
        console.log(taxInfo);
      });
    } else {
      console.log("No token taxes applicable.");
    }
  } else {
    console.log("No token metadata available.");
  }

  // 4. Sign permit2.eip712 returned from quote
  let signature: Hex | undefined;
  if (quote.permit2?.eip712) {
    try {
      signature = await client.signTypedData(quote.permit2.eip712);
      console.log("Signed permit2 message from quote response");
    } catch (error) {
      console.error("Error signing permit2 coupon:", error);
    }

    // 5. Append sig length and sig data to transaction.data
    if (signature && quote?.transaction?.data) {
      const signatureLengthInHex = numberToHex(size(signature), {
        signed: false,
        size: 32,
      });

      const transactionData = quote.transaction.data as Hex;
      const sigLengthHex = signatureLengthInHex as Hex;
      const sig = signature as Hex;

      quote.transaction.data = concat([transactionData, sigLengthHex, sig]);
    } else {
      throw new Error("Failed to obtain signature or transaction data");
    }
  }

  // 6. Submit transaction with permit2 signature
  if (signature && quote.transaction.data) {
    const nonce = await client.getTransactionCount({
      address: client.account.address,
    });

    const signedTransaction = await client.signTransaction({
      account: client.account,
      chain: client.chain,
      gas: !!quote?.transaction.gas
        ? BigInt(quote?.transaction.gas)
        : undefined,
      to: quote?.transaction.to,
      data: quote.transaction.data,
      value: quote?.transaction.value
        ? BigInt(quote.transaction.value)
        : undefined, // Value is used for native tokens
      gasPrice: !!quote?.transaction.gasPrice
        ? BigInt(quote?.transaction.gasPrice)
        : undefined,
      nonce: nonce,
    });
    const hash = await client.sendRawTransaction({
      serializedTransaction: signedTransaction,
    });

    console.log("Transaction hash:", hash);

    console.log(`See tx details at https://scrollscan.com/tx/${hash}`);
  } else {
    console.error("Failed to obtain a signature, transaction not sent.");
  }

  // Task 4: Display all sources of liquidity on Scroll
  const fetchLiquiditySources = async () => {
    const chainId = client.chain.id.toString();
    const sourcesUrl = `https://api.0x.org/sources?chainId=${chainId}`;

    try {
      const response = await fetch(sourcesUrl, { headers });
      const data = await response.json();

      if (data.sources && data.sources.length > 0) {
        console.log("Liquidity sources for Scroll chain:");
        data.sources.forEach((source) => {
          console.log(`    ${source.name}`);
        });
      } else {
        console.log("No liquidity sources found for the Scroll chain.");
      }
    } catch (error) {
      console.error("Error fetching liquidity sources:", error);
    }
  };

  // Call the function to fetch and display liquidity sources
  await fetchLiquiditySources();
};

// Execute the main function
main();
